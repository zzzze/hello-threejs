webpackJsonp([0],[
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderer = exports.scene = exports.height = exports.width = undefined;\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar width = exports.width = document.getElementById('canvas-frame').clientWidth;\nvar height = exports.height = document.getElementById('canvas-frame').clientHeight;\nvar scene = exports.scene = new THREE.Scene();\n\nfunction initThree() {\n  var renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(width, height);\n  renderer.setClearColor(0xFFFFFF, 1.0);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  document.getElementById('canvas-frame').appendChild(renderer.domElement);\n  return renderer;\n}\n\nvar renderer = exports.renderer = initThree();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5pdC5qcz9mMmQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5leHBvcnQgY29uc3Qgd2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWZyYW1lJykuY2xpZW50V2lkdGhcbmV4cG9ydCBjb25zdCBoZWlnaHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWZyYW1lJykuY2xpZW50SGVpZ2h0XG5leHBvcnQgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuXG5mdW5jdGlvbiBpbml0VGhyZWUgKCkge1xuICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBhbnRpYWxpYXM6IHRydWVcbiAgfSlcbiAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4RkZGRkZGLCAxLjApXG4gIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtZnJhbWUnKS5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICByZXR1cm4gcmVuZGVyZXJcbn1cblxuZXhwb3J0IGNvbnN0IHJlbmRlcmVyID0gaW5pdFRocmVlKClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5pdC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _init = __webpack_require__(1);\n\nvar _line = __webpack_require__(3);\n\nvar _line2 = _interopRequireDefault(_line);\n\nvar _light = __webpack_require__(4);\n\nvar _light2 = _interopRequireDefault(_light);\n\nvar _camera = __webpack_require__(5);\n\nvar _camera2 = _interopRequireDefault(_camera);\n\nvar _cube = __webpack_require__(6);\n\nvar _cube2 = _interopRequireDefault(_cube);\n\nvar _bunny = __webpack_require__(8);\n\nvar _bunny2 = _interopRequireDefault(_bunny);\n\nvar _VTKLoader = __webpack_require__(9);\n\nvar _VTKLoader2 = _interopRequireDefault(_VTKLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction run() {\n  console.log(_bunny2.default);\n  var loader = new _VTKLoader2.default();\n  loader.addEventListener('load', function (geometry) {\n    // const geometry = event.content\n    var material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });\n    var mesh = new THREE.Mesh(geometry, material);\n    mesh.position.setY(-0.09);\n    _init.scene.add(mesh);\n  });\n  loader.load(_bunny2.default);\n\n  _init.scene.add(_light2.default);\n  // scene.add(cube)\n  _init.scene.add(_line2.default);\n  animate();\n}\n\nfunction animate() {\n  // requestAnimationFrame(animate)\n  render();\n}\n\nfunction render() {\n  _cube2.default.rotation.y += 0.02;\n  _cube2.default.rotation.z += 0.01;\n\n  _init.renderer.clear();\n  _init.renderer.render(_init.scene, _camera2.default);\n}\n\nwindow.addEventListener('load', run);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbmltcG9ydCB7IHNjZW5lLCByZW5kZXJlciB9IGZyb20gJy4vaW5pdCdcbmltcG9ydCBsaW5lIGZyb20gJy4vbGluZSdcbmltcG9ydCBsaWdodCBmcm9tICcuL2xpZ2h0J1xuaW1wb3J0IGNhbWVyYSBmcm9tICcuL2NhbWVyYSdcbmltcG9ydCBjdWJlIGZyb20gJy4vY3ViZSdcbmltcG9ydCBidW5ueSBmcm9tICcuLi9yZXMvbW9kZWxzL2J1bm55LnZ0aydcbmltcG9ydCBWVEtMb2FkZXIgZnJvbSAnLi9sb2FkZXJzL1ZUS0xvYWRlcidcblxuZnVuY3Rpb24gcnVuICgpIHtcbiAgY29uc29sZS5sb2coYnVubnkpXG4gIGNvbnN0IGxvYWRlciA9IG5ldyBWVEtMb2FkZXIoKVxuICBsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgIC8vIGNvbnN0IGdlb21ldHJ5ID0gZXZlbnQuY29udGVudFxuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYsIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUgfSlcbiAgICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgIG1lc2gucG9zaXRpb24uc2V0WSgtMC4wOSlcbiAgICBzY2VuZS5hZGQobWVzaClcbiAgfSlcbiAgbG9hZGVyLmxvYWQoYnVubnkpXG5cbiAgc2NlbmUuYWRkKGxpZ2h0KVxuICAvLyBzY2VuZS5hZGQoY3ViZSlcbiAgc2NlbmUuYWRkKGxpbmUpXG4gIGFuaW1hdGUoKVxufVxuXG5mdW5jdGlvbiBhbmltYXRlICgpIHtcbiAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gIHJlbmRlcigpXG59XG5cbmZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIGN1YmUucm90YXRpb24ueSArPSAwLjAyXG4gIGN1YmUucm90YXRpb24ueiArPSAwLjAxXG5cbiAgcmVuZGVyZXIuY2xlYXIoKVxuICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSlcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBydW4pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction initObject() {\n  var geometry = new THREE.Geometry();\n  var material = new THREE.LineBasicMaterial({ vertexColors: true });\n  var color1 = new THREE.Color(0x00FF00);\n  var color2 = new THREE.Color(0xFF0000);\n\n  // 线的材质可以由2点的颜色决定\n  geometry.vertices.push(new THREE.Vector3(-500, 0, 0));\n  geometry.vertices.push(new THREE.Vector3(500, 0, 0));\n  geometry.colors.push(color1, color2);\n\n  return new THREE.Line(geometry, material, THREE.LineSegments);\n}\n\nexports.default = initObject();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGluZS5qcz8yYTNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5mdW5jdGlvbiBpbml0T2JqZWN0ICgpIHtcbiAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKVxuICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSB9KVxuICBjb25zdCBjb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoMHgwMEZGMDApXG4gIGNvbnN0IGNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvcigweEZGMDAwMClcblxuICAvLyDnur/nmoTmnZDotKjlj6/ku6XnlLEy54K555qE6aKc6Imy5Yaz5a6aXG4gIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoLTUwMCwgMCwgMCkpXG4gIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoNTAwLCAwLCAwKSlcbiAgZ2VvbWV0cnkuY29sb3JzLnB1c2goY29sb3IxLCBjb2xvcjIpXG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVNlZ21lbnRzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0T2JqZWN0KClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGluZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction initLight() {\n  var light = new THREE.DirectionalLight(0xFF0000, 1.0);\n  light.position.set(100, 100, 200);\n  return light;\n}\n\nexports.default = initLight();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGlnaHQuanM/N2EzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcblxuZnVuY3Rpb24gaW5pdExpZ2h0ICgpIHtcbiAgY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweEZGMDAwMCwgMS4wKVxuICBsaWdodC5wb3NpdGlvbi5zZXQoMTAwLCAxMDAsIDIwMClcbiAgcmV0dXJuIGxpZ2h0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRMaWdodCgpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpZ2h0LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _init = __webpack_require__(1);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction initCamera() {\n  var camera = new THREE.PerspectiveCamera(35, _init.width / _init.height, 1, 10000);\n  camera.position.x = 0;\n  camera.position.y = 0;\n  camera.position.z = 1000;\n  camera.up.x = 0;\n  camera.up.y = 1;\n  camera.up.z = 0;\n  camera.lookAt(0, 0, 0);\n\n  return camera;\n}\n\nexports.default = initCamera();\n\n// export default new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvY2FtZXJhLmpzP2FmMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5pbXBvcnQgeyB3aWR0aCwgaGVpZ2h0IH0gZnJvbSAnLi9pbml0J1xuXG5mdW5jdGlvbiBpbml0Q2FtZXJhICgpIHtcbiAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDM1LCB3aWR0aCAvIGhlaWdodCwgMSwgMTAwMDApXG4gIGNhbWVyYS5wb3NpdGlvbi54ID0gMFxuICBjYW1lcmEucG9zaXRpb24ueSA9IDBcbiAgY2FtZXJhLnBvc2l0aW9uLnogPSAxMDAwXG4gIGNhbWVyYS51cC54ID0gMFxuICBjYW1lcmEudXAueSA9IDFcbiAgY2FtZXJhLnVwLnogPSAwXG4gIGNhbWVyYS5sb29rQXQoMCwgMCwgMClcblxuICByZXR1cm4gY2FtZXJhXG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDYW1lcmEoKVxuXG4vLyBleHBvcnQgZGVmYXVsdCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDEwMDApXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhbWVyYS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _crate = __webpack_require__(7);\n\nvar _crate2 = _interopRequireDefault(_crate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// const geometry = new THREE.BoxGeometry(200, 200, 200)\n// for (let i = 0; i < geometry.faces.length; i += 2) {\n//   const hex = Math.random() * 0xffffff\n//   // const hex = 0xffffff\n//   geometry.faces[ i ].color.setHex(hex)\n//   geometry.faces[ i + 1 ].color.setHex(hex)\n// }\n// var material = new THREE.MeshBasicMaterial({color: 0xFFFFFF})\n\nvar geometry = new THREE.CubeGeometry(200, 200, 200, 4, 4);\n// const material = new THREE.MeshLambertMaterial({color: 0xFFFFFF})\nvar texture = new THREE.TextureLoader().load(_crate2.default);\nvar material = new THREE.MeshBasicMaterial({ map: texture });\nvar mesh = new THREE.Mesh(geometry, material);\nmesh.position.set(0, 0, 0);\n\nvar cube = new THREE.Mesh(geometry, material);\ncube.rotation.y = Math.PI / 4;\ncube.rotation.x = Math.PI / 8;\n\nexports.default = cube;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvY3ViZS5qcz8wZTA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuaW1wb3J0IGNyYXRlVGV4dHVyZSBmcm9tICcuLi9yZXMvdGV4dHVyZXMvY3JhdGUuZ2lmJ1xuXG4vLyBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyMDAsIDIwMCwgMjAwKVxuLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICBjb25zdCBoZXggPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbi8vICAgLy8gY29uc3QgaGV4ID0gMHhmZmZmZmZcbi8vICAgZ2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvci5zZXRIZXgoaGV4KVxuLy8gICBnZW9tZXRyeS5mYWNlc1sgaSArIDEgXS5jb2xvci5zZXRIZXgoaGV4KVxuLy8gfVxuLy8gdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjogMHhGRkZGRkZ9KVxuXG5jb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoMjAwLCAyMDAsIDIwMCwgNCwgNClcbi8vIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2NvbG9yOiAweEZGRkZGRn0pXG52YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZChjcmF0ZVRleHR1cmUpXG52YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHRleHR1cmUgfSlcbmNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpXG5tZXNoLnBvc2l0aW9uLnNldCgwLCAwLCAwKVxuXG5jb25zdCBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKVxuY3ViZS5yb3RhdGlvbi55ID0gTWF0aC5QSSAvIDRcbmN1YmUucm90YXRpb24ueCA9IE1hdGguUEkgLyA4XG5cbmV4cG9ydCBkZWZhdWx0IGN1YmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY3ViZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"da499b8537ee3ce0ed8469c0a73ecc2c.gif\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZXMvdGV4dHVyZXMvY3JhdGUuZ2lmP2VkOTMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZGE0OTliODUzN2VlM2NlMGVkODQ2OWMwYTczZWNjMmMuZ2lmXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVzL3RleHR1cmVzL2NyYXRlLmdpZlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"4de0b82bbd07d5d1d1cd2147b77380a2.vtk\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9yZXMvbW9kZWxzL2J1bm55LnZ0az85ZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRkZTBiODJiYmQwN2Q1ZDFkMWNkMjE0N2I3NzM4MGEyLnZ0a1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3Jlcy9tb2RlbHMvYnVubnkudnRrXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = VTKLoader;\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction VTKLoader(manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n} /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author Alex Pletzer\n   *\n   * Updated on 22.03.2017\n   * VTK header is now parsed and used to extract all the compressed data\n   * @author Andrii Iudin https://github.com/andreyyudin\n   * @author Paul Kibet Korir https://github.com/polarise\n   * @author Sriram Somasundharam https://github.com/raamssundar\n   */\n\n\nObject.assign(VTKLoader.prototype, THREE.EventDispatcher.prototype, {\n\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text));\n    }, onProgress, onError);\n  },\n\n  parse: function parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      var indices = [];\n\n      // triangles vertices\n      var positions = [];\n\n      // red, green, blue colors in the range 0 to 1\n      var colors = [];\n\n      // normal vector, one per vertex\n      var normals = [];\n\n      var result;\n\n      // pattern for reading vertices, 3 floats or integers\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n      // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n      // indicates start of vertex data section\n      var patPOINTS = /^POINTS /;\n\n      // indicates start of polygon connectivity section\n      var patPOLYGONS = /^POLYGONS /;\n\n      // indicates start of triangle strips section\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n      // POINT_DATA number_of_values\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n      // CELL_DATA number_of_polys\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n      // Start of color section\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n      // NORMALS Normals float\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n      var inPointsSection = false;\n      var inPolygonsSection = false;\n      var inTriangleStripSection = false;\n      var inPointDataSection = false;\n      var inCellDataSection = false;\n      var inColorSection = false;\n      var inNormalsSection = false;\n\n      var lines = data.split('\\n');\n\n      for (var i in lines) {\n        var line = lines[i];\n\n        if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            var x = parseFloat(result[1]);\n            var y = parseFloat(result[2]);\n            var z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0 = parseInt(inds[0]);\n              var i1, i2;\n              var k = 1;\n              // split the polygon in numVertices - 2 triangles\n              for (var j = 0; j < numVertices - 2; ++j) {\n                i1 = parseInt(inds[k]);\n                i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            var numVertices = parseInt(result[1]);\n            var inds = result[2].split(/\\s+/);\n\n            if (numVertices >= 3) {\n              var i0, i1, i2;\n              // split the polygon in numVertices - 2 triangles\n              for (var j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 2]);\n                  i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  i0 = parseInt(inds[j]);\n                  i1 = parseInt(inds[j + 1]);\n                  i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              var r = parseFloat(result[1]);\n              var g = parseFloat(result[2]);\n              var b = parseFloat(result[3]);\n              colors.push(r, g, b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              var nx = parseFloat(result[1]);\n              var ny = parseFloat(result[2]);\n              var nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n\n      var geometry;\n      var stagger = 'point';\n\n      if (colors.length === indices.length) {\n        stagger = 'cell';\n      }\n\n      if (stagger === 'point') {\n        // Nodal. Use BufferGeometry\n        geometry = new THREE.BufferGeometry();\n        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));\n\n        if (colors.length === positions.length) {\n          geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n        }\n\n        if (normals.length === positions.length) {\n          geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n        }\n      } else {\n        // Cell centered colors. The only way to attach a solid color to each triangle\n        // is to use Geometry, which is less efficient than BufferGeometry\n        geometry = new THREE.Geometry();\n\n        var numTriangles = indices.length / 3;\n        var numPoints = positions.length / 3;\n        var face;\n        var ia, ib, ic;\n        var x, y, z;\n        var r, g, b;\n\n        for (var j = 0; j < numPoints; ++j) {\n          x = positions[3 * j + 0];\n          y = positions[3 * j + 1];\n          z = positions[3 * j + 2];\n          geometry.vertices.push(new THREE.Vector3(x, y, z));\n        }\n\n        for (var i = 0; i < numTriangles; ++i) {\n          ia = indices[3 * i + 0];\n          ib = indices[3 * i + 1];\n          ic = indices[3 * i + 2];\n          geometry.faces.push(new THREE.Face3(ia, ib, ic));\n        }\n\n        if (colors.length === numTriangles * 3) {\n          for (var i = 0; i < numTriangles; ++i) {\n            face = geometry.faces[i];\n            r = colors[3 * i + 0];\n            g = colors[3 * i + 1];\n            b = colors[3 * i + 2];\n            face.color = new THREE.Color().setRGB(r, g, b);\n          }\n        }\n      }\n\n      return geometry;\n    }\n\n    function parseBinary(data) {\n      var count, pointIndex, i, numberOfPoints, s;\n      var buffer = new Uint8Array(data);\n      var dataView = new DataView(data);\n\n      // Points and normals, by default, are empty\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      // Going to make a big array of strings\n      var vtk = [];\n      var index = 0;\n\n      function findString(buffer, start) {\n        var index = start;\n        var c = buffer[index];\n        var s = [];\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n\n        return { start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('') };\n      }\n\n      var state, line;\n\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n\n        if (line.indexOf('POINTS') === 0) {\n          vtk.push(line);\n          // Add the points\n          numberOfPoints = parseInt(line.split(' ')[1], 10);\n\n          // Each point is 3 4-byte floats\n          count = numberOfPoints * 4 * 3;\n\n          points = new Float32Array(numberOfPoints * 3);\n\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          }\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10);\n          // 4 byte integers\n          count = size * 4;\n\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n\n            // retrieves the n-2 triangles from the triangle strip\n            for (var j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          }\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\n          var size = parseInt(line.split(' ')[2], 10);\n          // 4 byte integers\n          count = size * 4;\n\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          var indicesIndex = 0;\n\n          pointIndex = state.next;\n          for (i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            var indexCount = dataView.getInt32(pointIndex, false);\n            var strip = [];\n            pointIndex += 4;\n            for (s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n\n            // divide the polygon in n-2 triangle\n            for (var j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          }\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          numberOfPoints = parseInt(line.split(' ')[1], 10);\n\n          // Grab the next line\n          state = findString(buffer, state.next);\n\n          // Now grab the binary data\n          count = numberOfPoints * 4 * 3;\n\n          normals = new Float32Array(numberOfPoints * 3);\n          pointIndex = state.next;\n          for (i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          }\n\n          // Increment past our data\n          state.next = state.next + count;\n        }\n\n        // Increment index\n        index = state.next;\n\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n\n      var geometry = new THREE.BufferGeometry();\n      geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n      geometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n      if (normals.length === points.length) {\n        geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n      }\n\n      return geometry;\n    }\n\n    function Float32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Float32Array(firstLength + second.length);\n\n      result.set(first);\n      result.set(second, firstLength);\n\n      return result;\n    }\n\n    function Int32Concat(first, second) {\n      var firstLength = first.length,\n          result = new Int32Array(firstLength + second.length);\n\n      result.set(first);\n      result.set(second, firstLength);\n\n      return result;\n    }\n\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n      function xmlToJson(xml) {\n        // Create the return object\n        var obj = {};\n\n        if (xml.nodeType === 1) {\n          // element\n          // do attributes\n\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n\n              for (var j = 0; j < xml.attributes.length; j++) {\n                var attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n          obj = xml.nodeValue.trim();\n        }\n\n        // do children\n        if (xml.hasChildNodes()) {\n          for (var i = 0; i < xml.childNodes.length; i++) {\n            var item = xml.childNodes.item(i);\n            var nodeName = item.nodeName;\n\n            if (typeof obj[nodeName] === 'undefined') {\n              var tmp = xmlToJson(item);\n\n              if (tmp !== '') obj[nodeName] = tmp;\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                var old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n\n              var tmp = xmlToJson(item);\n\n              if (tmp !== '') obj[nodeName].push(tmp);\n            }\n          }\n        }\n\n        return obj;\n      }\n\n      // Taken from Base64-js\n      function Base64toByteArray(b64) {\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        var i;\n        var lookup = [];\n        var revLookup = [];\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        var len = code.length;\n\n        for (i = 0; i < len; i++) {\n          lookup[i] = code[i];\n        }\n\n        for (i = 0; i < len; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n\n        var j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        arr = new Arr(len * 3 / 4 - placeHolders);\n        l = placeHolders > 0 ? len - 4 : len;\n\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xFF0000) >> 16;\n          arr[L++] = (tmp & 0xFF00) >> 8;\n          arr[L++] = tmp & 0xFF;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xFF;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xFF;\n          arr[L++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function parseDataArray(ele, compressed) {\n        var numBytes = 0;\n\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        }\n\n        // Check the format\n        if (ele.attributes.format === 'binary' && compressed) {\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array();\n          }\n\n          // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n          rawData = ele['#text'];\n\n          byteData = Base64toByteArray(rawData);\n\n          blocks = byteData[0];\n          for (var i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * numBytes;\n          }\n\n          headerSize = (blocks + 3) * numBytes;\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n\n          dataOffsets = [];\n          currentOffset = headerSize;\n          dataOffsets.push(currentOffset);\n\n          // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n          cSizeStart = 3 * numBytes;\n\n          for (var i = 0; i < blocks; i++) {\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n            for (var j = 1; j < numBytes - 1; j++) {\n              // Each data point consists of 8 bytes regardless of the header type\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n            }\n\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\n            var inflate = new Zlib.Inflate(byteData.slice(dataOffsets[i], dataOffsets[i + 1]), { resize: true, verify: true }); // eslint-disable-line no-undef\n            content = inflate.decompress();\n            content = content.buffer;\n\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n\n          delete ele['#text'];\n\n          // Get the content and optimize it\n          if (ele.attributes.type === 'Float32') {\n            if (ele.attributes.format === 'binary') {\n              if (!compressed) {\n                txt = txt.filter(function (el, idx) {\n                  if (idx !== 0) return true;\n                });\n              }\n            }\n          } else if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              if (!compressed) {\n                txt = txt.filter(function (el, idx) {\n                  if (idx !== 0) return true;\n                });\n              }\n\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            var content = Base64toByteArray(ele['#text']);\n\n            //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              var content = new Int32Array(0).buffer;\n            }\n          }\n\n          delete ele['#text'];\n\n          // Get the content and optimize it\n          if (ele.attributes.type === 'Float32') {\n            var txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            var txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            var txt = new Int32Array(content);\n\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n        return txt;\n      }\n\n      // Main part\n      // Get Dom\n      var dom = null;\n\n      if (window.DOMParser) {\n        try {\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n        } catch (e) {\n          dom = null;\n        }\n      } else if (window.ActiveXObject) {\n        try {\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n          dom.async = false;\n\n          if (!dom.loadXML()) {\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\n          }\n        } catch (e) {\n          dom = null;\n        }\n      } else {\n        throw new Error('Cannot parse xml string!');\n      }\n\n      // Get the doc\n      var doc = dom.documentElement;\n      // Convert to json\n      var json = xmlToJson(doc);\n      var points = [];\n      var normals = [];\n      var indices = [];\n\n      if (json.PolyData) {\n        var piece = json.PolyData.Piece;\n        var compressed = json.attributes.hasOwnProperty('compressor');\n\n        // Can be optimized\n        // Loop through the sections\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n        var sectionIndex = 0,\n            numberOfSections = sections.length;\n\n        while (sectionIndex < numberOfSections) {\n          var section = piece[sections[sectionIndex]];\n\n          // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n              var arr = section.DataArray;\n            } else {\n              var arr = [section.DataArray];\n            }\n\n            var dataArrayIndex = 0,\n                numberOfDataArrays = arr.length;\n\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n\n              dataArrayIndex++;\n            }\n\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                var normalsName = section.attributes.Normals;\n\n                if (numberOfPoints > 0) {\n                  for (var i = 0, len = arr.length; i < len; i++) {\n                    if (normalsName === arr[i].attributes.Name) {\n                      var components = arr[i].attributes.NumberOfComponents;\n                      normals = new Float32Array(numberOfPoints * components);\n                      normals.set(arr[i].text, 0);\n                    }\n                  }\n                }\n\n                break;\n\n              // if it is points\n              case 'Points':\n\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                if (numberOfPoints > 0) {\n                  var components = section.DataArray.attributes.NumberOfComponents;\n                  points = new Float32Array(numberOfPoints * components);\n                  points.set(section.DataArray.text, 0);\n                }\n\n                break;\n\n              // if it is strips\n              case 'Strips':\n\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                if (numberOfStrips > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n\n                  var size = numberOfStrips + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\n                  var indicesIndex = 0;\n\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\n                    var strip = [];\n\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                      strip.push(connectivity[s]);\n\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                      if (j % 2) {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 2];\n                        indices[indicesIndex++] = strip[j + 1];\n                      } else {\n                        indices[indicesIndex++] = strip[j];\n                        indices[indicesIndex++] = strip[j + 1];\n                        indices[indicesIndex++] = strip[j + 2];\n                      }\n\n                      if (i > 0) len0 = offset[i - 1];\n                    }\n                  }\n                }\n\n                break;\n\n              // if it is polys\n              case 'Polys':\n\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                if (numberOfPolys > 0) {\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\n                  var offset = new Int32Array(section.DataArray[1].text.length);\n                  connectivity.set(section.DataArray[0].text, 0);\n                  offset.set(section.DataArray[1].text, 0);\n\n                  var size = numberOfPolys + connectivity.length;\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                  var indicesIndex = 0,\n                      connectivityIndex = 0;\n                  var i = 0,\n                      len = numberOfPolys,\n                      len0 = 0;\n\n                  while (i < len) {\n                    var poly = [];\n                    var s = 0,\n                        len1 = offset[i];\n\n                    while (s < len1 - len0) {\n                      poly.push(connectivity[connectivityIndex++]);\n                      s++;\n                    }\n\n                    var j = 1;\n\n                    while (j < len1 - len0 - 1) {\n                      indices[indicesIndex++] = poly[0];\n                      indices[indicesIndex++] = poly[j];\n                      indices[indicesIndex++] = poly[j + 1];\n                      j++;\n                    }\n\n                    i++;\n                    len0 = offset[i - 1];\n                  }\n                }\n\n                break;\n\n              default:\n                break;\n            }\n          }\n\n          sectionIndex++;\n        }\n\n        var geometry = new THREE.BufferGeometry();\n        geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n        geometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      } else {\n\n        // TODO for vtu,vti,and other xml formats\n\n      }\n    }\n\n    function getStringFile(data) {\n      var stringFile = '';\n      var charArray = new Uint8Array(data);\n      var i = 0;\n      var len = charArray.length;\n\n      while (len--) {\n        stringFile += String.fromCharCode(charArray[i++]);\n      }\n\n      return stringFile;\n    }\n\n    // get the 5 first lines of the files to check if there is the key word binary\n    console.log(data);\n    var meta = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n    console.log(meta);\n\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(getStringFile(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(getStringFile(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbG9hZGVycy9WVEtMb2FkZXIuanM/OWQ5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIEFsZXggUGxldHplclxuICpcbiAqIFVwZGF0ZWQgb24gMjIuMDMuMjAxN1xuICogVlRLIGhlYWRlciBpcyBub3cgcGFyc2VkIGFuZCB1c2VkIHRvIGV4dHJhY3QgYWxsIHRoZSBjb21wcmVzc2VkIGRhdGFcbiAqIEBhdXRob3IgQW5kcmlpIEl1ZGluIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZXl5dWRpblxuICogQGF1dGhvciBQYXVsIEtpYmV0IEtvcmlyIGh0dHBzOi8vZ2l0aHViLmNvbS9wb2xhcmlzZVxuICogQGF1dGhvciBTcmlyYW0gU29tYXN1bmRoYXJhbSBodHRwczovL2dpdGh1Yi5jb20vcmFhbXNzdW5kYXJcbiAqL1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZUS0xvYWRlciAobWFuYWdlcikge1xuICB0aGlzLm1hbmFnZXIgPSAobWFuYWdlciAhPT0gdW5kZWZpbmVkKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXJcbn1cblxuT2JqZWN0LmFzc2lnbihWVEtMb2FkZXIucHJvdG90eXBlLCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cbiAgbG9hZDogZnVuY3Rpb24gKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpc1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5GaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpXG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKVxuICAgIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIG9uTG9hZChzY29wZS5wYXJzZSh0ZXh0KSlcbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yKVxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGZ1bmN0aW9uIHBhcnNlQVNDSUkgKGRhdGEpIHtcbi8vIGNvbm5lY3Rpdml0eSBvZiB0aGUgdHJpYW5nbGVzXG4gICAgICB2YXIgaW5kaWNlcyA9IFtdXG5cbi8vIHRyaWFuZ2xlcyB2ZXJ0aWNlc1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdXG5cbi8vIHJlZCwgZ3JlZW4sIGJsdWUgY29sb3JzIGluIHRoZSByYW5nZSAwIHRvIDFcbiAgICAgIHZhciBjb2xvcnMgPSBbXVxuXG4vLyBub3JtYWwgdmVjdG9yLCBvbmUgcGVyIHZlcnRleFxuICAgICAgdmFyIG5vcm1hbHMgPSBbXVxuXG4gICAgICB2YXIgcmVzdWx0XG5cbi8vIHBhdHRlcm4gZm9yIHJlYWRpbmcgdmVydGljZXMsIDMgZmxvYXRzIG9yIGludGVnZXJzXG4gICAgICB2YXIgcGF0M0Zsb2F0cyA9IC8oXFwtP1xcZCtcXC4/W1xcZFxcLVxcK2VdKilcXHMrKFxcLT9cXGQrXFwuP1tcXGRcXC1cXCtlXSopXFxzKyhcXC0/XFxkK1xcLj9bXFxkXFwtXFwrZV0qKS9nXG5cbi8vIHBhdHRlcm4gZm9yIGNvbm5lY3Rpdml0eSwgYW4gaW50ZWdlciBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGludHNcbi8vIHRoZSBmaXJzdCBpbnRlZ2VyIGlzIHRoZSBudW1iZXIgb2YgcG9seWdvbiBub2Rlc1xuICAgICAgdmFyIHBhdENvbm5lY3Rpdml0eSA9IC9eKFxcZCspXFxzKyhbXFxzXFxkXSopL1xuXG4vLyBpbmRpY2F0ZXMgc3RhcnQgb2YgdmVydGV4IGRhdGEgc2VjdGlvblxuICAgICAgdmFyIHBhdFBPSU5UUyA9IC9eUE9JTlRTIC9cblxuLy8gaW5kaWNhdGVzIHN0YXJ0IG9mIHBvbHlnb24gY29ubmVjdGl2aXR5IHNlY3Rpb25cbiAgICAgIHZhciBwYXRQT0xZR09OUyA9IC9eUE9MWUdPTlMgL1xuXG4vLyBpbmRpY2F0ZXMgc3RhcnQgb2YgdHJpYW5nbGUgc3RyaXBzIHNlY3Rpb25cbiAgICAgIHZhciBwYXRUUklBTkdMRV9TVFJJUFMgPSAvXlRSSUFOR0xFX1NUUklQUyAvXG5cbi8vIFBPSU5UX0RBVEEgbnVtYmVyX29mX3ZhbHVlc1xuICAgICAgdmFyIHBhdFBPSU5UX0RBVEEgPSAvXlBPSU5UX0RBVEFbIF0rKFxcZCspL1xuXG4vLyBDRUxMX0RBVEEgbnVtYmVyX29mX3BvbHlzXG4gICAgICB2YXIgcGF0Q0VMTF9EQVRBID0gL15DRUxMX0RBVEFbIF0rKFxcZCspL1xuXG4vLyBTdGFydCBvZiBjb2xvciBzZWN0aW9uXG4gICAgICB2YXIgcGF0Q09MT1JfU0NBTEFSUyA9IC9eQ09MT1JfU0NBTEFSU1sgXSsoXFx3KylbIF0rMy9cblxuLy8gTk9STUFMUyBOb3JtYWxzIGZsb2F0XG4gICAgICB2YXIgcGF0Tk9STUFMUyA9IC9eTk9STUFMU1sgXSsoXFx3KylbIF0rKFxcdyspL1xuXG4gICAgICB2YXIgaW5Qb2ludHNTZWN0aW9uID0gZmFsc2VcbiAgICAgIHZhciBpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlXG4gICAgICB2YXIgaW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlXG4gICAgICB2YXIgaW5Qb2ludERhdGFTZWN0aW9uID0gZmFsc2VcbiAgICAgIHZhciBpbkNlbGxEYXRhU2VjdGlvbiA9IGZhbHNlXG4gICAgICB2YXIgaW5Db2xvclNlY3Rpb24gPSBmYWxzZVxuICAgICAgdmFyIGluTm9ybWFsc1NlY3Rpb24gPSBmYWxzZVxuXG4gICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KCdcXG4nKVxuXG4gICAgICBmb3IgKHZhciBpIGluIGxpbmVzKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbIGkgXVxuXG4gICAgICAgIGlmIChpblBvaW50c1NlY3Rpb24pIHtcbi8vIGdldCB0aGUgdmVydGljZXNcbiAgICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHBhdDNGbG9hdHMuZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChyZXN1bHRbIDEgXSlcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChyZXN1bHRbIDIgXSlcbiAgICAgICAgICAgIHZhciB6ID0gcGFyc2VGbG9hdChyZXN1bHRbIDMgXSlcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIHksIHopXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGluUG9seWdvbnNTZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBwYXRDb25uZWN0aXZpdHkuZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcbi8vIG51bVZlcnRpY2VzIGkwIGkxIGkyIC4uLlxuICAgICAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gcGFyc2VJbnQocmVzdWx0WyAxIF0pXG4gICAgICAgICAgICB2YXIgaW5kcyA9IHJlc3VsdFsgMiBdLnNwbGl0KC9cXHMrLylcblxuICAgICAgICAgICAgaWYgKG51bVZlcnRpY2VzID49IDMpIHtcbiAgICAgICAgICAgICAgdmFyIGkwID0gcGFyc2VJbnQoaW5kc1sgMCBdKVxuICAgICAgICAgICAgICB2YXIgaTEsIGkyXG4gICAgICAgICAgICAgIHZhciBrID0gMVxuLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gbnVtVmVydGljZXMgLSAyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVZlcnRpY2VzIC0gMjsgKytqKSB7XG4gICAgICAgICAgICAgICAgaTEgPSBwYXJzZUludChpbmRzWyBrIF0pXG4gICAgICAgICAgICAgICAgaTIgPSBwYXJzZUludChpbmRzWyBrICsgMSBdKVxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpMCwgaTEsIGkyKVxuICAgICAgICAgICAgICAgIGsrK1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGluVHJpYW5nbGVTdHJpcFNlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IHBhdENvbm5lY3Rpdml0eS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuLy8gbnVtVmVydGljZXMgaTAgaTEgaTIgLi4uXG4gICAgICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBwYXJzZUludChyZXN1bHRbIDEgXSlcbiAgICAgICAgICAgIHZhciBpbmRzID0gcmVzdWx0WyAyIF0uc3BsaXQoL1xccysvKVxuXG4gICAgICAgICAgICBpZiAobnVtVmVydGljZXMgPj0gMykge1xuICAgICAgICAgICAgICB2YXIgaTAsIGkxLCBpMlxuLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gbnVtVmVydGljZXMgLSAyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVZlcnRpY2VzIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpMCA9IHBhcnNlSW50KGluZHNbIGogXSlcbiAgICAgICAgICAgICAgICAgIGkxID0gcGFyc2VJbnQoaW5kc1sgaiArIDIgXSlcbiAgICAgICAgICAgICAgICAgIGkyID0gcGFyc2VJbnQoaW5kc1sgaiArIDEgXSlcbiAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpMCwgaTEsIGkyKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpMCA9IHBhcnNlSW50KGluZHNbIGogXSlcbiAgICAgICAgICAgICAgICAgIGkxID0gcGFyc2VJbnQoaW5kc1sgaiArIDEgXSlcbiAgICAgICAgICAgICAgICAgIGkyID0gcGFyc2VJbnQoaW5kc1sgaiArIDIgXSlcbiAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpMCwgaTEsIGkyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpblBvaW50RGF0YVNlY3Rpb24gfHwgaW5DZWxsRGF0YVNlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoaW5Db2xvclNlY3Rpb24pIHtcbi8vIEdldCB0aGUgY29sb3JzXG5cbiAgICAgICAgICAgIHdoaWxlICgocmVzdWx0ID0gcGF0M0Zsb2F0cy5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlRmxvYXQocmVzdWx0WyAxIF0pXG4gICAgICAgICAgICAgIHZhciBnID0gcGFyc2VGbG9hdChyZXN1bHRbIDIgXSlcbiAgICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUZsb2F0KHJlc3VsdFsgMyBdKVxuICAgICAgICAgICAgICBjb2xvcnMucHVzaChyLCBnLCBiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5Ob3JtYWxzU2VjdGlvbikge1xuLy8gR2V0IHRoZSBub3JtYWwgdmVjdG9yc1xuXG4gICAgICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHBhdDNGbG9hdHMuZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIG54ID0gcGFyc2VGbG9hdChyZXN1bHRbIDEgXSlcbiAgICAgICAgICAgICAgdmFyIG55ID0gcGFyc2VGbG9hdChyZXN1bHRbIDIgXSlcbiAgICAgICAgICAgICAgdmFyIG56ID0gcGFyc2VGbG9hdChyZXN1bHRbIDMgXSlcbiAgICAgICAgICAgICAgbm9ybWFscy5wdXNoKG54LCBueSwgbnopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdFBPTFlHT05TLmV4ZWMobGluZSkgIT09IG51bGwpIHtcbiAgICAgICAgICBpblBvbHlnb25zU2VjdGlvbiA9IHRydWVcbiAgICAgICAgICBpblBvaW50c1NlY3Rpb24gPSBmYWxzZVxuICAgICAgICAgIGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHBhdFBPSU5UUy5leGVjKGxpbmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5Qb2x5Z29uc1NlY3Rpb24gPSBmYWxzZVxuICAgICAgICAgIGluUG9pbnRzU2VjdGlvbiA9IHRydWVcbiAgICAgICAgICBpblRyaWFuZ2xlU3RyaXBTZWN0aW9uID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChwYXRUUklBTkdMRV9TVFJJUFMuZXhlYyhsaW5lKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGluUG9seWdvbnNTZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICBpblBvaW50c1NlY3Rpb24gPSBmYWxzZVxuICAgICAgICAgIGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAocGF0UE9JTlRfREFUQS5leGVjKGxpbmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5Qb2ludERhdGFTZWN0aW9uID0gdHJ1ZVxuICAgICAgICAgIGluUG9pbnRzU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5Qb2x5Z29uc1NlY3Rpb24gPSBmYWxzZVxuICAgICAgICAgIGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHBhdENFTExfREFUQS5leGVjKGxpbmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5DZWxsRGF0YVNlY3Rpb24gPSB0cnVlXG4gICAgICAgICAgaW5Qb2ludHNTZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICBpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocGF0Q09MT1JfU0NBTEFSUy5leGVjKGxpbmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5Db2xvclNlY3Rpb24gPSB0cnVlXG4gICAgICAgICAgaW5Ob3JtYWxzU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5Qb2ludHNTZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICBpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocGF0Tk9STUFMUy5leGVjKGxpbmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5Ob3JtYWxzU2VjdGlvbiA9IHRydWVcbiAgICAgICAgICBpbkNvbG9yU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5Qb2ludHNTZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICBpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgaW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21ldHJ5XG4gICAgICB2YXIgc3RhZ2dlciA9ICdwb2ludCdcblxuICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHN0YWdnZXIgPSAnY2VsbCdcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YWdnZXIgPT09ICdwb2ludCcpIHtcbi8vIE5vZGFsLiBVc2UgQnVmZmVyR2VvbWV0cnlcbiAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50MzJBcnJheShpbmRpY2VzKSwgMSkpXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKSwgMykpXG5cbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IHBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGNvbG9ycyksIDMpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbHMubGVuZ3RoID09PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkobm9ybWFscyksIDMpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuLy8gQ2VsbCBjZW50ZXJlZCBjb2xvcnMuIFRoZSBvbmx5IHdheSB0byBhdHRhY2ggYSBzb2xpZCBjb2xvciB0byBlYWNoIHRyaWFuZ2xlXG4vLyBpcyB0byB1c2UgR2VvbWV0cnksIHdoaWNoIGlzIGxlc3MgZWZmaWNpZW50IHRoYW4gQnVmZmVyR2VvbWV0cnlcbiAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKVxuXG4gICAgICAgIHZhciBudW1UcmlhbmdsZXMgPSBpbmRpY2VzLmxlbmd0aCAvIDNcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzXG4gICAgICAgIHZhciBmYWNlXG4gICAgICAgIHZhciBpYSwgaWIsIGljXG4gICAgICAgIHZhciB4LCB5LCB6XG4gICAgICAgIHZhciByLCBnLCBiXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Qb2ludHM7ICsraikge1xuICAgICAgICAgIHggPSBwb3NpdGlvbnNbIDMgKiBqICsgMCBdXG4gICAgICAgICAgeSA9IHBvc2l0aW9uc1sgMyAqIGogKyAxIF1cbiAgICAgICAgICB6ID0gcG9zaXRpb25zWyAzICogaiArIDIgXVxuICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeikpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRyaWFuZ2xlczsgKytpKSB7XG4gICAgICAgICAgaWEgPSBpbmRpY2VzWyAzICogaSArIDAgXVxuICAgICAgICAgIGliID0gaW5kaWNlc1sgMyAqIGkgKyAxIF1cbiAgICAgICAgICBpYyA9IGluZGljZXNbIDMgKiBpICsgMiBdXG4gICAgICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoaWEsIGliLCBpYykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gbnVtVHJpYW5nbGVzICogMykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJpYW5nbGVzOyArK2kpIHtcbiAgICAgICAgICAgIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1sgaSBdXG4gICAgICAgICAgICByID0gY29sb3JzWyAzICogaSArIDAgXVxuICAgICAgICAgICAgZyA9IGNvbG9yc1sgMyAqIGkgKyAxIF1cbiAgICAgICAgICAgIGIgPSBjb2xvcnNbIDMgKiBpICsgMiBdXG4gICAgICAgICAgICBmYWNlLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKHIsIGcsIGIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZW9tZXRyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5IChkYXRhKSB7XG4gICAgICB2YXIgY291bnQsIHBvaW50SW5kZXgsIGksIG51bWJlck9mUG9pbnRzLCBzXG4gICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSlcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhKVxuXG4vLyBQb2ludHMgYW5kIG5vcm1hbHMsIGJ5IGRlZmF1bHQsIGFyZSBlbXB0eVxuICAgICAgdmFyIHBvaW50cyA9IFtdXG4gICAgICB2YXIgbm9ybWFscyA9IFtdXG4gICAgICB2YXIgaW5kaWNlcyA9IFtdXG5cbi8vIEdvaW5nIHRvIG1ha2UgYSBiaWcgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgdmFyIHZ0ayA9IFtdXG4gICAgICB2YXIgaW5kZXggPSAwXG5cbiAgICAgIGZ1bmN0aW9uIGZpbmRTdHJpbmcgKGJ1ZmZlciwgc3RhcnQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhcnRcbiAgICAgICAgdmFyIGMgPSBidWZmZXJbIGluZGV4IF1cbiAgICAgICAgdmFyIHMgPSBbXVxuICAgICAgICB3aGlsZSAoYyAhPT0gMTApIHtcbiAgICAgICAgICBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgYyA9IGJ1ZmZlclsgaW5kZXggXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgbmV4dDogaW5kZXggKyAxLFxuICAgICAgICAgIHBhcnNlZFN0cmluZzogcy5qb2luKCcnKSB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSwgbGluZVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuLy8gR2V0IGEgc3RyaW5nXG4gICAgICAgIHN0YXRlID0gZmluZFN0cmluZyhidWZmZXIsIGluZGV4KVxuICAgICAgICBsaW5lID0gc3RhdGUucGFyc2VkU3RyaW5nXG5cbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignUE9JTlRTJykgPT09IDApIHtcbiAgICAgICAgICB2dGsucHVzaChsaW5lKVxuLy8gQWRkIHRoZSBwb2ludHNcbiAgICAgICAgICBudW1iZXJPZlBvaW50cyA9IHBhcnNlSW50KGxpbmUuc3BsaXQoJyAnKVsgMSBdLCAxMClcblxuLy8gRWFjaCBwb2ludCBpcyAzIDQtYnl0ZSBmbG9hdHNcbiAgICAgICAgICBjb3VudCA9IG51bWJlck9mUG9pbnRzICogNCAqIDNcblxuICAgICAgICAgIHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtYmVyT2ZQb2ludHMgKiAzKVxuXG4gICAgICAgICAgcG9pbnRJbmRleCA9IHN0YXRlLm5leHRcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZQb2ludHM7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzWyAzICogaSBdID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb2ludEluZGV4LCBmYWxzZSlcbiAgICAgICAgICAgIHBvaW50c1sgMyAqIGkgKyAxIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvaW50SW5kZXggKyA0LCBmYWxzZSlcbiAgICAgICAgICAgIHBvaW50c1sgMyAqIGkgKyAyIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvaW50SW5kZXggKyA4LCBmYWxzZSlcbiAgICAgICAgICAgIHBvaW50SW5kZXggPSBwb2ludEluZGV4ICsgMTJcbiAgICAgICAgICB9XG4vLyBpbmNyZW1lbnQgb3VyIG5leHQgcG9pbnRlclxuICAgICAgICAgIHN0YXRlLm5leHQgPSBzdGF0ZS5uZXh0ICsgY291bnQgKyAxXG4gICAgICAgIH0gZWxzZSBpZiAobGluZS5pbmRleE9mKCdUUklBTkdMRV9TVFJJUFMnKSA9PT0gMCkge1xuICAgICAgICAgIHZhciBudW1iZXJPZlN0cmlwcyA9IHBhcnNlSW50KGxpbmUuc3BsaXQoJyAnKVsgMSBdLCAxMClcbiAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KGxpbmUuc3BsaXQoJyAnKVsgMiBdLCAxMClcbi8vIDQgYnl0ZSBpbnRlZ2Vyc1xuICAgICAgICAgIGNvdW50ID0gc2l6ZSAqIDRcblxuICAgICAgICAgIGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoMyAqIHNpemUgLSA5ICogbnVtYmVyT2ZTdHJpcHMpXG4gICAgICAgICAgdmFyIGluZGljZXNJbmRleCA9IDBcblxuICAgICAgICAgIHBvaW50SW5kZXggPSBzdGF0ZS5uZXh0XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mU3RyaXBzOyBpKyspIHtcbi8vIEZvciBlYWNoIHN0cmlwLCByZWFkIHRoZSBmaXJzdCB2YWx1ZSwgdGhlbiByZWNvcmQgdGhhdCBtYW55IG1vcmUgcG9pbnRzXG4gICAgICAgICAgICB2YXIgaW5kZXhDb3VudCA9IGRhdGFWaWV3LmdldEludDMyKHBvaW50SW5kZXgsIGZhbHNlKVxuICAgICAgICAgICAgdmFyIHN0cmlwID0gW11cbiAgICAgICAgICAgIHBvaW50SW5kZXggKz0gNFxuICAgICAgICAgICAgZm9yIChzID0gMDsgcyA8IGluZGV4Q291bnQ7IHMrKykge1xuICAgICAgICAgICAgICBzdHJpcC5wdXNoKGRhdGFWaWV3LmdldEludDMyKHBvaW50SW5kZXgsIGZhbHNlKSlcbiAgICAgICAgICAgICAgcG9pbnRJbmRleCArPSA0XG4gICAgICAgICAgICB9XG5cbi8vIHJldHJpZXZlcyB0aGUgbi0yIHRyaWFuZ2xlcyBmcm9tIHRoZSB0cmlhbmdsZSBzdHJpcFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbmRleENvdW50IC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqICUgMikge1xuICAgICAgICAgICAgICAgIGluZGljZXNbIGluZGljZXNJbmRleCsrIF0gPSBzdHJpcFsgaiBdXG4gICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqICsgMiBdXG4gICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqICsgMSBdXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqIF1cbiAgICAgICAgICAgICAgICBpbmRpY2VzWyBpbmRpY2VzSW5kZXgrKyBdID0gc3RyaXBbIGogKyAxIF1cbiAgICAgICAgICAgICAgICBpbmRpY2VzWyBpbmRpY2VzSW5kZXgrKyBdID0gc3RyaXBbIGogKyAyIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbi8vIGluY3JlbWVudCBvdXIgbmV4dCBwb2ludGVyXG4gICAgICAgICAgc3RhdGUubmV4dCA9IHN0YXRlLm5leHQgKyBjb3VudCArIDFcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ1BPTFlHT05TJykgPT09IDApIHtcbiAgICAgICAgICB2YXIgbnVtYmVyT2ZTdHJpcHMgPSBwYXJzZUludChsaW5lLnNwbGl0KCcgJylbIDEgXSwgMTApXG4gICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChsaW5lLnNwbGl0KCcgJylbIDIgXSwgMTApXG4vLyA0IGJ5dGUgaW50ZWdlcnNcbiAgICAgICAgICBjb3VudCA9IHNpemUgKiA0XG5cbiAgICAgICAgICBpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KDMgKiBzaXplIC0gOSAqIG51bWJlck9mU3RyaXBzKVxuICAgICAgICAgIHZhciBpbmRpY2VzSW5kZXggPSAwXG5cbiAgICAgICAgICBwb2ludEluZGV4ID0gc3RhdGUubmV4dFxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZlN0cmlwczsgaSsrKSB7XG4vLyBGb3IgZWFjaCBzdHJpcCwgcmVhZCB0aGUgZmlyc3QgdmFsdWUsIHRoZW4gcmVjb3JkIHRoYXQgbWFueSBtb3JlIHBvaW50c1xuICAgICAgICAgICAgdmFyIGluZGV4Q291bnQgPSBkYXRhVmlldy5nZXRJbnQzMihwb2ludEluZGV4LCBmYWxzZSlcbiAgICAgICAgICAgIHZhciBzdHJpcCA9IFtdXG4gICAgICAgICAgICBwb2ludEluZGV4ICs9IDRcbiAgICAgICAgICAgIGZvciAocyA9IDA7IHMgPCBpbmRleENvdW50OyBzKyspIHtcbiAgICAgICAgICAgICAgc3RyaXAucHVzaChkYXRhVmlldy5nZXRJbnQzMihwb2ludEluZGV4LCBmYWxzZSkpXG4gICAgICAgICAgICAgIHBvaW50SW5kZXggKz0gNFxuICAgICAgICAgICAgfVxuXG4vLyBkaXZpZGUgdGhlIHBvbHlnb24gaW4gbi0yIHRyaWFuZ2xlXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGluZGV4Q291bnQgLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyAwIF1cbiAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqIF1cbiAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqICsgMSBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuLy8gaW5jcmVtZW50IG91ciBuZXh0IHBvaW50ZXJcbiAgICAgICAgICBzdGF0ZS5uZXh0ID0gc3RhdGUubmV4dCArIGNvdW50ICsgMVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5kZXhPZignUE9JTlRfREFUQScpID09PSAwKSB7XG4gICAgICAgICAgbnVtYmVyT2ZQb2ludHMgPSBwYXJzZUludChsaW5lLnNwbGl0KCcgJylbIDEgXSwgMTApXG5cbi8vIEdyYWIgdGhlIG5leHQgbGluZVxuICAgICAgICAgIHN0YXRlID0gZmluZFN0cmluZyhidWZmZXIsIHN0YXRlLm5leHQpXG5cbi8vIE5vdyBncmFiIHRoZSBiaW5hcnkgZGF0YVxuICAgICAgICAgIGNvdW50ID0gbnVtYmVyT2ZQb2ludHMgKiA0ICogM1xuXG4gICAgICAgICAgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtYmVyT2ZQb2ludHMgKiAzKVxuICAgICAgICAgIHBvaW50SW5kZXggPSBzdGF0ZS5uZXh0XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIG5vcm1hbHNbIDMgKiBpIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvaW50SW5kZXgsIGZhbHNlKVxuICAgICAgICAgICAgbm9ybWFsc1sgMyAqIGkgKyAxIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvaW50SW5kZXggKyA0LCBmYWxzZSlcbiAgICAgICAgICAgIG5vcm1hbHNbIDMgKiBpICsgMiBdID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb2ludEluZGV4ICsgOCwgZmFsc2UpXG4gICAgICAgICAgICBwb2ludEluZGV4ICs9IDEyXG4gICAgICAgICAgfVxuXG4vLyBJbmNyZW1lbnQgcGFzdCBvdXIgZGF0YVxuICAgICAgICAgIHN0YXRlLm5leHQgPSBzdGF0ZS5uZXh0ICsgY291bnRcbiAgICAgICAgfVxuXG4vLyBJbmNyZW1lbnQgaW5kZXhcbiAgICAgICAgaW5kZXggPSBzdGF0ZS5uZXh0XG5cbiAgICAgICAgaWYgKGluZGV4ID49IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShpbmRpY2VzLCAxKSlcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHBvaW50cywgMykpXG5cbiAgICAgIGlmIChub3JtYWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZW9tZXRyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZsb2F0MzJDb25jYXQgKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIHZhciBmaXJzdExlbmd0aCA9IGZpcnN0Lmxlbmd0aCwgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShmaXJzdExlbmd0aCArIHNlY29uZC5sZW5ndGgpXG5cbiAgICAgIHJlc3VsdC5zZXQoZmlyc3QpXG4gICAgICByZXN1bHQuc2V0KHNlY29uZCwgZmlyc3RMZW5ndGgpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbnQzMkNvbmNhdCAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgdmFyIGZpcnN0TGVuZ3RoID0gZmlyc3QubGVuZ3RoLCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShmaXJzdExlbmd0aCArIHNlY29uZC5sZW5ndGgpXG5cbiAgICAgIHJlc3VsdC5zZXQoZmlyc3QpXG4gICAgICByZXN1bHQuc2V0KHNlY29uZCwgZmlyc3RMZW5ndGgpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVhNTCAoc3RyaW5nRmlsZSkge1xuLy8gQ2hhbmdlcyBYTUwgdG8gSlNPTiwgYmFzZWQgb24gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvY29udmVydC14bWwtanNvblxuXG4gICAgICBmdW5jdGlvbiB4bWxUb0pzb24gKHhtbCkge1xuLy8gQ3JlYXRlIHRoZSByZXR1cm4gb2JqZWN0XG4gICAgICAgIHZhciBvYmogPSB7fVxuXG4gICAgICAgIGlmICh4bWwubm9kZVR5cGUgPT09IDEpIHsgLy8gZWxlbWVudFxuLy8gZG8gYXR0cmlidXRlc1xuXG4gICAgICAgICAgaWYgKHhtbC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoeG1sLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBvYmpbICdhdHRyaWJ1dGVzJyBdID0ge31cblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHhtbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHhtbC5hdHRyaWJ1dGVzLml0ZW0oailcbiAgICAgICAgICAgICAgICBvYmpbICdhdHRyaWJ1dGVzJyBdWyBhdHRyaWJ1dGUubm9kZU5hbWUgXSA9IGF0dHJpYnV0ZS5ub2RlVmFsdWUudHJpbSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoeG1sLm5vZGVUeXBlID09PSAzKSB7IC8vIHRleHRcbiAgICAgICAgICBvYmogPSB4bWwubm9kZVZhbHVlLnRyaW0oKVxuICAgICAgICB9XG5cbi8vIGRvIGNoaWxkcmVuXG4gICAgICAgIGlmICh4bWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB4bWwuY2hpbGROb2Rlcy5pdGVtKGkpXG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBpdGVtLm5vZGVOYW1lXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqWyBub2RlTmFtZSBdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB2YXIgdG1wID0geG1sVG9Kc29uKGl0ZW0pXG5cbiAgICAgICAgICAgICAgaWYgKHRtcCAhPT0gJycpIG9ialsgbm9kZU5hbWUgXSA9IHRtcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbIG5vZGVOYW1lIF0ucHVzaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gb2JqWyBub2RlTmFtZSBdXG4gICAgICAgICAgICAgICAgb2JqWyBub2RlTmFtZSBdID0gWyBvbGQgXVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHRtcCA9IHhtbFRvSnNvbihpdGVtKVxuXG4gICAgICAgICAgICAgIGlmICh0bXAgIT09ICcnKSBvYmpbIG5vZGVOYW1lIF0ucHVzaCh0bXApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuXG4vLyBUYWtlbiBmcm9tIEJhc2U2NC1qc1xuICAgICAgZnVuY3Rpb24gQmFzZTY0dG9CeXRlQXJyYXkgKGI2NCkge1xuICAgICAgICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG4gICAgICAgIHZhciBpXG4gICAgICAgIHZhciBsb29rdXAgPSBbXVxuICAgICAgICB2YXIgcmV2TG9va3VwID0gW11cbiAgICAgICAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUubGVuZ3RoXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgbG9va3VwWyBpIF0gPSBjb2RlWyBpIF1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHJldkxvb2t1cFsgY29kZS5jaGFyQ29kZUF0KGkpIF0gPSBpXG4gICAgICAgIH1cblxuICAgICAgICByZXZMb29rdXBbICctJy5jaGFyQ29kZUF0KDApIF0gPSA2MlxuICAgICAgICByZXZMb29rdXBbICdfJy5jaGFyQ29kZUF0KDApIF0gPSA2M1xuXG4gICAgICAgIHZhciBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gICAgICAgIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgICAgICAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgICAgICAgfVxuXG4gICAgICAgIHBsYWNlSG9sZGVycyA9IGI2NFsgbGVuIC0gMiBdID09PSAnPScgPyAyIDogYjY0WyBsZW4gLSAxIF0gPT09ICc9JyA/IDEgOiAwXG4gICAgICAgIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG4gICAgICAgIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gICAgICAgIHZhciBMID0gMFxuXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICAgICAgICB0bXAgPSAocmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdChpKSBdIDw8IDE4KSB8IChyZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KGkgKyAxKSBdIDw8IDEyKSB8IChyZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KGkgKyAyKSBdIDw8IDYpIHwgcmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdChpICsgMykgXVxuICAgICAgICAgIGFyclsgTCsrIF0gPSAodG1wICYgMHhGRjAwMDApID4+IDE2XG4gICAgICAgICAgYXJyWyBMKysgXSA9ICh0bXAgJiAweEZGMDApID4+IDhcbiAgICAgICAgICBhcnJbIEwrKyBdID0gdG1wICYgMHhGRlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgICAgICAgIHRtcCA9IChyZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KGkpIF0gPDwgMikgfCAocmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdChpICsgMSkgXSA+PiA0KVxuICAgICAgICAgIGFyclsgTCsrIF0gPSB0bXAgJiAweEZGXG4gICAgICAgIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgICAgICAgdG1wID0gKHJldkxvb2t1cFsgYjY0LmNoYXJDb2RlQXQoaSkgXSA8PCAxMCkgfCAocmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdChpICsgMSkgXSA8PCA0KSB8IChyZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KGkgKyAyKSBdID4+IDIpXG4gICAgICAgICAgYXJyWyBMKysgXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgICAgICAgYXJyWyBMKysgXSA9IHRtcCAmIDB4RkZcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFyc2VEYXRhQXJyYXkgKGVsZSwgY29tcHJlc3NlZCkge1xuICAgICAgICB2YXIgbnVtQnl0ZXMgPSAwXG5cbiAgICAgICAgaWYgKGpzb24uYXR0cmlidXRlcy5oZWFkZXJfdHlwZSA9PT0gJ1VJbnQ2NCcpIHtcbiAgICAgICAgICBudW1CeXRlcyA9IDhcbiAgICAgICAgfVx0ZWxzZSBpZiAoanNvbi5hdHRyaWJ1dGVzLmhlYWRlcl90eXBlID09PSAnVUludDMyJykge1xuICAgICAgICAgIG51bUJ5dGVzID0gNFxuICAgICAgICB9XG5cbi8vIENoZWNrIHRoZSBmb3JtYXRcbiAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ2JpbmFyeScgJiYgY29tcHJlc3NlZCkge1xuICAgICAgICAgIHZhciByYXdEYXRhLCBjb250ZW50LCBieXRlRGF0YSwgYmxvY2tzLCBjU2l6ZVN0YXJ0LCBoZWFkZXJTaXplLCBwYWRkaW5nLCBkYXRhT2Zmc2V0cywgY3VycmVudE9mZnNldFxuXG4gICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdGbG9hdDMyJykge1xuICAgICAgICAgICAgdmFyIHR4dCA9IG5ldyBGbG9hdDMyQXJyYXkoKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0Jykge1xuICAgICAgICAgICAgdmFyIHR4dCA9IG5ldyBJbnQzMkFycmF5KClcbiAgICAgICAgICB9XG5cbi8vIFZUUCBkYXRhIHdpdGggdGhlIGhlYWRlciBoYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4vLyBbI2Jsb2Nrc11bI3Utc2l6ZV1bI3Atc2l6ZV1bI2Mtc2l6ZS0xXVsjYy1zaXplLTJdLi4uWyNjLXNpemUtI2Jsb2Nrc11bREFUQV1cbi8vXG4vLyBFYWNoIHRva2VuIGlzIGFuIGludGVnZXIgdmFsdWUgd2hvc2UgdHlwZSBpcyBzcGVjaWZpZWQgYnkgXCJoZWFkZXJfdHlwZVwiIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgKFVJbnQzMiBpZiBubyB0eXBlIHNwZWNpZmllZCkuIFRoZSB0b2tlbiBtZWFuaW5ncyBhcmU6XG4vLyBbI2Jsb2Nrc10gPSBOdW1iZXIgb2YgYmxvY2tzXG4vLyBbI3Utc2l6ZV0gPSBCbG9jayBzaXplIGJlZm9yZSBjb21wcmVzc2lvblxuLy8gWyNwLXNpemVdID0gU2l6ZSBvZiBsYXN0IHBhcnRpYWwgYmxvY2sgKHplcm8gaWYgaXQgbm90IG5lZWRlZClcbi8vIFsjYy1zaXplLWldID0gU2l6ZSBpbiBieXRlcyBvZiBibG9jayBpIGFmdGVyIGNvbXByZXNzaW9uXG4vL1xuLy8gVGhlIFtEQVRBXSBwb3J0aW9uIHN0b3JlcyBjb250aWd1b3VzbHkgZXZlcnkgYmxvY2sgYXBwZW5kZWQgdG9nZXRoZXIuIFRoZSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXRhIHNlY3Rpb24gdG8gdGhlIGJlZ2lubmluZyBvZiBhIGJsb2NrIGlzXG4vLyBjb21wdXRlZCBieSBzdW1taW5nIHRoZSBjb21wcmVzc2VkIGJsb2NrIHNpemVzIGZyb20gcHJlY2VkaW5nIGJsb2NrcyBhY2NvcmRpbmcgdG8gdGhlIGhlYWRlci5cblxuICAgICAgICAgIHJhd0RhdGEgPSBlbGVbICcjdGV4dCcgXVxuXG4gICAgICAgICAgYnl0ZURhdGEgPSBCYXNlNjR0b0J5dGVBcnJheShyYXdEYXRhKVxuXG4gICAgICAgICAgYmxvY2tzID0gYnl0ZURhdGFbIDAgXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtQnl0ZXMgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGJsb2NrcyA9IGJsb2NrcyB8IChieXRlRGF0YVsgaSBdIDw8IChpICogbnVtQnl0ZXMpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlYWRlclNpemUgPSAoYmxvY2tzICsgMykgKiBudW1CeXRlc1xuICAgICAgICAgIHBhZGRpbmcgPSAoKGhlYWRlclNpemUgJSAzKSA+IDApID8gMyAtIChoZWFkZXJTaXplICUgMykgOiAwXG4gICAgICAgICAgaGVhZGVyU2l6ZSA9IGhlYWRlclNpemUgKyBwYWRkaW5nXG5cbiAgICAgICAgICBkYXRhT2Zmc2V0cyA9IFtdXG4gICAgICAgICAgY3VycmVudE9mZnNldCA9IGhlYWRlclNpemVcbiAgICAgICAgICBkYXRhT2Zmc2V0cy5wdXNoKGN1cnJlbnRPZmZzZXQpXG5cbi8vIEdldCB0aGUgYmxvY2tzIHNpemVzIGFmdGVyIHRoZSBjb21wcmVzc2lvbi5cbi8vIFRoZXJlIGFyZSB0aHJlZSBibG9ja3MgYmVmb3JlIGMtc2l6ZS1pLCBzbyB3ZSBza2lwIDMqbnVtQnl0ZXNcbiAgICAgICAgICBjU2l6ZVN0YXJ0ID0gMyAqIG51bUJ5dGVzXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEJsb2NrU2l6ZSA9IGJ5dGVEYXRhWyBpICogbnVtQnl0ZXMgKyBjU2l6ZVN0YXJ0IF1cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBudW1CeXRlcyAtIDE7IGorKykge1xuLy8gRWFjaCBkYXRhIHBvaW50IGNvbnNpc3RzIG9mIDggYnl0ZXMgcmVnYXJkbGVzcyBvZiB0aGUgaGVhZGVyIHR5cGVcbiAgICAgICAgICAgICAgY3VycmVudEJsb2NrU2l6ZSA9IGN1cnJlbnRCbG9ja1NpemUgfCAoYnl0ZURhdGFbIGkgKiBudW1CeXRlcyArIGNTaXplU3RhcnQgKyBqIF0gPDwgKGogKiA4KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudE9mZnNldCA9IGN1cnJlbnRPZmZzZXQgKyBjdXJyZW50QmxvY2tTaXplXG4gICAgICAgICAgICBkYXRhT2Zmc2V0cy5wdXNoKGN1cnJlbnRPZmZzZXQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhT2Zmc2V0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmZsYXRlID0gbmV3IFpsaWIuSW5mbGF0ZShieXRlRGF0YS5zbGljZShkYXRhT2Zmc2V0c1sgaSBdLCBkYXRhT2Zmc2V0c1sgaSArIDEgXSksIHsgcmVzaXplOiB0cnVlLCB2ZXJpZnk6IHRydWUgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgICAgICAgY29udGVudCA9IGluZmxhdGUuZGVjb21wcmVzcygpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5idWZmZXJcblxuICAgICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdGbG9hdDMyJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gbmV3IEZsb2F0MzJBcnJheShjb250ZW50KVxuICAgICAgICAgICAgICB0eHQgPSBGbG9hdDMyQ29uY2F0KHR4dCwgY29udGVudClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0Jykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gbmV3IEludDMyQXJyYXkoY29udGVudClcbiAgICAgICAgICAgICAgdHh0ID0gSW50MzJDb25jYXQodHh0LCBjb250ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBlbGVbICcjdGV4dCcgXVxuXG4vLyBHZXQgdGhlIGNvbnRlbnQgYW5kIG9wdGltaXplIGl0XG4gICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdGbG9hdDMyJykge1xuICAgICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgdHh0ID0gdHh0LmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gMCkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGUuYXR0cmlidXRlcy50eXBlID09PSAnSW50NjQnKSB7XG4gICAgICAgICAgICBpZiAoZWxlLmF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgICBpZiAoIWNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICB0eHQgPSB0eHQuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAwKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0eHQgPSB0eHQuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAlIDIgIT09IDEpIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGUuYXR0cmlidXRlcy5mb3JtYXQgPT09ICdiaW5hcnknICYmICFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IEJhc2U2NHRvQnl0ZUFycmF5KGVsZVsgJyN0ZXh0JyBdKVxuXG4vLyAgVlRQIGRhdGEgZm9yIHRoZSB1bmNvbXByZXNzZWQgY2FzZSBoYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4vLyBbI2J5dGVzXVtEQVRBXVxuLy8gd2hlcmUgXCJbI2J5dGVzXVwiIGlzIGFuIGludGVnZXIgdmFsdWUgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9jayBvZiBkYXRhIGZvbGxvd2luZyBpdC5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKG51bUJ5dGVzKS5idWZmZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVsZVsgJyN0ZXh0JyBdKSB7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZWxlWyAnI3RleHQnIF0uc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSAnJykgcmV0dXJuIGVsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IG5ldyBJbnQzMkFycmF5KDApLmJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBlbGVbICcjdGV4dCcgXVxuXG4vLyBHZXQgdGhlIGNvbnRlbnQgYW5kIG9wdGltaXplIGl0XG4gICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdGbG9hdDMyJykge1xuICAgICAgICAgICAgdmFyIHR4dCA9IG5ldyBGbG9hdDMyQXJyYXkoY29udGVudClcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgIHZhciB0eHQgPSBuZXcgSW50MzJBcnJheShjb250ZW50KVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0Jykge1xuICAgICAgICAgICAgdmFyIHR4dCA9IG5ldyBJbnQzMkFycmF5KGNvbnRlbnQpXG5cbiAgICAgICAgICAgIGlmIChlbGUuYXR0cmlidXRlcy5mb3JtYXQgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgICAgIHR4dCA9IHR4dC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICUgMiAhPT0gMSkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kaWYgKCBlbGUuYXR0cmlidXRlcy5mb3JtYXQgPT09ICdiaW5hcnknICYmIGNvbXByZXNzZWQgKVxuXG4gICAgICAgIHJldHVybiB0eHRcbiAgICAgIH1cblxuLy8gTWFpbiBwYXJ0XG4vLyBHZXQgRG9tXG4gICAgICB2YXIgZG9tID0gbnVsbFxuXG4gICAgICBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvbSA9IChuZXcgRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyhzdHJpbmdGaWxlLCAndGV4dC94bWwnKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZG9tID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgICAgZG9tLmFzeW5jID0gZmFsc2VcblxuICAgICAgICAgIGlmICghZG9tLmxvYWRYTUwoLyogeG1sICovKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRvbS5wYXJzZUVycm9yLnJlYXNvbiArIGRvbS5wYXJzZUVycm9yLnNyY1RleHQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZG9tID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB4bWwgc3RyaW5nIScpXG4gICAgICB9XG5cbi8vIEdldCB0aGUgZG9jXG4gICAgICB2YXIgZG9jID0gZG9tLmRvY3VtZW50RWxlbWVudFxuLy8gQ29udmVydCB0byBqc29uXG4gICAgICB2YXIganNvbiA9IHhtbFRvSnNvbihkb2MpXG4gICAgICB2YXIgcG9pbnRzID0gW11cbiAgICAgIHZhciBub3JtYWxzID0gW11cbiAgICAgIHZhciBpbmRpY2VzID0gW11cblxuICAgICAgaWYgKGpzb24uUG9seURhdGEpIHtcbiAgICAgICAgdmFyIHBpZWNlID0ganNvbi5Qb2x5RGF0YS5QaWVjZVxuICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGpzb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSgnY29tcHJlc3NvcicpXG5cbi8vIENhbiBiZSBvcHRpbWl6ZWRcbi8vIExvb3AgdGhyb3VnaCB0aGUgc2VjdGlvbnNcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gWyAnUG9pbnREYXRhJywgJ1BvaW50cycsICdTdHJpcHMnLCAnUG9seXMnIF0vLyArWydDZWxsRGF0YScsICdWZXJ0cycsICdMaW5lcyddO1xuICAgICAgICB2YXIgc2VjdGlvbkluZGV4ID0gMCwgbnVtYmVyT2ZTZWN0aW9ucyA9IHNlY3Rpb25zLmxlbmd0aFxuXG4gICAgICAgIHdoaWxlIChzZWN0aW9uSW5kZXggPCBudW1iZXJPZlNlY3Rpb25zKSB7XG4gICAgICAgICAgdmFyIHNlY3Rpb24gPSBwaWVjZVsgc2VjdGlvbnNbIHNlY3Rpb25JbmRleCBdIF1cblxuLy8gSWYgaXQgaGFzIGEgRGF0YUFycmF5IGluIGl0XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbiAmJiBzZWN0aW9uLkRhdGFBcnJheSkge1xuLy8gRGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2YgRGF0YUFycmF5c1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlY3Rpb24uRGF0YUFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gc2VjdGlvbi5EYXRhQXJyYXlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhcnIgPSBbIHNlY3Rpb24uRGF0YUFycmF5IF1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFBcnJheUluZGV4ID0gMCwgbnVtYmVyT2ZEYXRhQXJyYXlzID0gYXJyLmxlbmd0aFxuXG4gICAgICAgICAgICB3aGlsZSAoZGF0YUFycmF5SW5kZXggPCBudW1iZXJPZkRhdGFBcnJheXMpIHtcbi8vIFBhcnNlIHRoZSBEYXRhQXJyYXlcbiAgICAgICAgICAgICAgaWYgKCgnI3RleHQnIGluIGFyclsgZGF0YUFycmF5SW5kZXggXSkgJiYgKGFyclsgZGF0YUFycmF5SW5kZXggXVsgJyN0ZXh0JyBdLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgYXJyWyBkYXRhQXJyYXlJbmRleCBdLnRleHQgPSBwYXJzZURhdGFBcnJheShhcnJbIGRhdGFBcnJheUluZGV4IF0sIGNvbXByZXNzZWQpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkYXRhQXJyYXlJbmRleCsrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VjdGlvbnNbIHNlY3Rpb25JbmRleCBdKSB7XG4vLyBpZiBpdGkgaXMgcG9pbnQgZGF0YVxuICAgICAgICAgICAgICBjYXNlICdQb2ludERhdGEnOlxuXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlck9mUG9pbnRzID0gcGFyc2VJbnQocGllY2UuYXR0cmlidXRlcy5OdW1iZXJPZlBvaW50cylcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsc05hbWUgPSBzZWN0aW9uLmF0dHJpYnV0ZXMuTm9ybWFsc1xuXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlck9mUG9pbnRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsc05hbWUgPT09IGFyclsgaSBdLmF0dHJpYnV0ZXMuTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gYXJyWyBpIF0uYXR0cmlidXRlcy5OdW1iZXJPZkNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShudW1iZXJPZlBvaW50cyAqIGNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgbm9ybWFscy5zZXQoYXJyWyBpIF0udGV4dCwgMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbi8vIGlmIGl0IGlzIHBvaW50c1xuICAgICAgICAgICAgICBjYXNlICdQb2ludHMnOlxuXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlck9mUG9pbnRzID0gcGFyc2VJbnQocGllY2UuYXR0cmlidXRlcy5OdW1iZXJPZlBvaW50cylcblxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZlBvaW50cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gc2VjdGlvbi5EYXRhQXJyYXkuYXR0cmlidXRlcy5OdW1iZXJPZkNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgIHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtYmVyT2ZQb2ludHMgKiBjb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgcG9pbnRzLnNldChzZWN0aW9uLkRhdGFBcnJheS50ZXh0LCAwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbi8vIGlmIGl0IGlzIHN0cmlwc1xuICAgICAgICAgICAgICBjYXNlICdTdHJpcHMnOlxuXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlck9mU3RyaXBzID0gcGFyc2VJbnQocGllY2UuYXR0cmlidXRlcy5OdW1iZXJPZlN0cmlwcylcblxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZlN0cmlwcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aXZpdHkgPSBuZXcgSW50MzJBcnJheShzZWN0aW9uLkRhdGFBcnJheVsgMCBdLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBJbnQzMkFycmF5KHNlY3Rpb24uRGF0YUFycmF5WyAxIF0udGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHkuc2V0KHNlY3Rpb24uRGF0YUFycmF5WyAwIF0udGV4dCwgMClcbiAgICAgICAgICAgICAgICAgIG9mZnNldC5zZXQoc2VjdGlvbi5EYXRhQXJyYXlbIDEgXS50ZXh0LCAwKVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG51bWJlck9mU3RyaXBzICsgY29ubmVjdGl2aXR5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSgzICogc2l6ZSAtIDkgKiBudW1iZXJPZlN0cmlwcylcblxuICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXNJbmRleCA9IDBcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG51bWJlck9mU3RyaXBzOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmlwID0gW11cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgbGVuMSA9IG9mZnNldFsgaSBdLCBsZW4wID0gMDsgcyA8IGxlbjEgLSBsZW4wOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpcC5wdXNoKGNvbm5lY3Rpdml0eVsgcyBdKVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSBsZW4wID0gb2Zmc2V0WyBpIC0gMSBdXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMSA9IG9mZnNldFsgaSBdLCBsZW4wID0gMDsgaiA8IGxlbjEgLSBsZW4wIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGogJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzWyBpbmRpY2VzSW5kZXgrKyBdID0gc3RyaXBbIGogXVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqICsgMiBdXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzWyBpbmRpY2VzSW5kZXgrKyBdID0gc3RyaXBbIGogKyAxIF1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNbIGluZGljZXNJbmRleCsrIF0gPSBzdHJpcFsgaiArIDEgXVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHN0cmlwWyBqICsgMiBdXG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSBsZW4wID0gb2Zmc2V0WyBpIC0gMSBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuXG4vLyBpZiBpdCBpcyBwb2x5c1xuICAgICAgICAgICAgICBjYXNlICdQb2x5cyc6XG5cbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyT2ZQb2x5cyA9IHBhcnNlSW50KHBpZWNlLmF0dHJpYnV0ZXMuTnVtYmVyT2ZQb2x5cylcblxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZlBvbHlzID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eSA9IG5ldyBJbnQzMkFycmF5KHNlY3Rpb24uRGF0YUFycmF5WyAwIF0udGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbmV3IEludDMyQXJyYXkoc2VjdGlvbi5EYXRhQXJyYXlbIDEgXS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eS5zZXQoc2VjdGlvbi5EYXRhQXJyYXlbIDAgXS50ZXh0LCAwKVxuICAgICAgICAgICAgICAgICAgb2Zmc2V0LnNldChzZWN0aW9uLkRhdGFBcnJheVsgMSBdLnRleHQsIDApXG5cbiAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gbnVtYmVyT2ZQb2x5cyArIGNvbm5lY3Rpdml0eS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgIGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoMyAqIHNpemUgLSA5ICogbnVtYmVyT2ZQb2x5cylcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzSW5kZXggPSAwLCBjb25uZWN0aXZpdHlJbmRleCA9IDBcbiAgICAgICAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gbnVtYmVyT2ZQb2x5cywgbGVuMCA9IDBcblxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBbXVxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAsIGxlbjEgPSBvZmZzZXRbIGkgXVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzIDwgbGVuMSAtIGxlbjApIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb2x5LnB1c2goY29ubmVjdGl2aXR5WyBjb25uZWN0aXZpdHlJbmRleCsrIF0pXG4gICAgICAgICAgICAgICAgICAgICAgcysrXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IDFcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbjEgLSBsZW4wIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNbIGluZGljZXNJbmRleCsrIF0gPSBwb2x5WyAwIF1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzWyBpbmRpY2VzSW5kZXgrKyBdID0gcG9seVsgaiBdXG4gICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1sgaW5kaWNlc0luZGV4KysgXSA9IHBvbHlbIGogKyAxIF1cbiAgICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICAgICBsZW4wID0gb2Zmc2V0WyBpIC0gMSBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VjdGlvbkluZGV4KytcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgMSkpXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHBvaW50cywgMykpXG5cbiAgICAgICAgaWYgKG5vcm1hbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5XG4gICAgICB9IGVsc2Uge1xuXG4vLyBUT0RPIGZvciB2dHUsdnRpLGFuZCBvdGhlciB4bWwgZm9ybWF0c1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RyaW5nRmlsZSAoZGF0YSkge1xuICAgICAgdmFyIHN0cmluZ0ZpbGUgPSAnJ1xuICAgICAgdmFyIGNoYXJBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIHZhciBsZW4gPSBjaGFyQXJyYXkubGVuZ3RoXG5cbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBzdHJpbmdGaWxlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckFycmF5WyBpKysgXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmluZ0ZpbGVcbiAgICB9XG5cbi8vIGdldCB0aGUgNSBmaXJzdCBsaW5lcyBvZiB0aGUgZmlsZXMgdG8gY2hlY2sgaWYgdGhlcmUgaXMgdGhlIGtleSB3b3JkIGJpbmFyeVxuICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgdmFyIG1ldGEgPSBUSFJFRS5Mb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIDI1MCkpLnNwbGl0KCdcXG4nKVxuICAgIGNvbnNvbGUubG9nKG1ldGEpXG5cbiAgICBpZiAobWV0YVsgMCBdLmluZGV4T2YoJ3htbCcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHBhcnNlWE1MKGdldFN0cmluZ0ZpbGUoZGF0YSkpXG4gICAgfSBlbHNlIGlmIChtZXRhWyAyIF0uaW5jbHVkZXMoJ0FTQ0lJJykpIHtcbiAgICAgIHJldHVybiBwYXJzZUFTQ0lJKGdldFN0cmluZ0ZpbGUoZGF0YSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZUJpbmFyeShkYXRhKVxuICAgIH1cbiAgfVxuXG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXJzL1ZUS0xvYWRlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFZQTtBQUNBO0FBSEE7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFySEE7QUF1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOTNCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n");

/***/ })
],[2]);